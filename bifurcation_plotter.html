<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bifurcation Diagram Explorer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Crimson+Pro:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0e17;
            --bg-med: #151b2b;
            --bg-light: #1f2937;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #ffbe0b;
            --text-primary: #e8edf4;
            --text-secondary: #9ca3af;
            --border: #2d3748;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --arrow-up: #7eb8da;
            --arrow-down: #e8a0a0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #0d1420 50%, var(--bg-dark) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                linear-gradient(rgba(0, 217, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 217, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }

        header { text-align: center; margin-bottom: 50px; }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: -2px;
            animation: fadeInDown 0.8s ease-out;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            font-weight: 400;
            animation: fadeIn 1s ease-out 0.3s both;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            animation: slideIn 0.8s ease-out 0.5s both;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .control-panel {
            background: var(--bg-med);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            height: fit-content;
        }

        .section { margin-bottom: 30px; }

        .section-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--accent-primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 3px;
            height: 14px;
            background: var(--accent-primary);
            display: inline-block;
        }

        label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(0, 217, 255, 0.1);
        }

        .equation-label {
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .equation-label .math { font-style: italic; }

        .range-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .btn {
            width: 100%;
            padding: 14px 24px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), #0099cc);
            color: var(--bg-dark);
            box-shadow: 0 4px 15px rgba(0, 217, 255, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 217, 255, 0.4);
        }
        
        .btn-secondary {
            background: var(--bg-light);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--bg-med);
            border-color: var(--accent-primary);
        }
        
        .btn-update {
            background: linear-gradient(135deg, var(--accent-tertiary), #cc9900);
            color: var(--bg-dark);
            box-shadow: 0 4px 15px rgba(255, 190, 11, 0.3);
        }
        
        .btn-update:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 190, 11, 0.4);
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 10px 16px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .preset-btn:hover {
            background: var(--bg-med);
            border-color: var(--accent-secondary);
            transform: translateX(4px);
        }

        .plot-container {
            background: var(--bg-med);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            min-height: 600px;
        }

        #plot {
            width: 100%;
            height: 700px;
            border-radius: 8px;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.05);
            border-left: 3px solid var(--accent-primary);
            padding: 15px;
            border-radius: 6px;
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .info-box strong {
            color: var(--accent-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .method-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            margin-left: 8px;
            text-transform: uppercase;
        }
        
        .method-analytical {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid #10b981;
        }
        
        .method-numerical {
            background: rgba(255, 190, 11, 0.2);
            color: #ffbe0b;
            border: 1px solid #ffbe0b;
        }
        
        .method-error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
        }

        .syntax-guide {
            background: var(--bg-light);
            border-radius: 6px;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.8;
        }

        .syntax-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .syntax-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .syntax-key { color: var(--accent-secondary); }
        .syntax-value { color: var(--text-secondary); }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .loading.active { display: block; }

        .spinner {
            border: 3px solid var(--bg-light);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #bifurcationInfo {
            margin-top: 15px;
            padding: 12px;
            background: var(--bg-light);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .error-message {
            color: var(--error);
            font-size: 0.85rem;
            margin-top: 8px;
            padding: 8px;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 4px;
            border-left: 3px solid var(--error);
        }

        @media (max-width: 1024px) {
            .main-content { grid-template-columns: 1fr; }
            h1 { font-size: 2.5rem; }
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--accent-primary); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Bifurcation Diagram Explorer</h1>
            <p class="subtitle">Visualize dynamical systems and stability transitions</p>
            <p class="subtitle" style="margin-top: 10px; font-size: 0.95rem; opacity: 0.7;">Made by <span style="color: var(--accent-primary); font-weight: 600;">Arzaan Singh</span></p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="section">
                    <div class="section-title">Equation</div>
                    <div class="equation-label">
                        <span class="math">d</span><input type="text" id="varInput" value="x" style="width: 50px; display: inline-block; margin: 0 5px; padding: 4px 8px; font-size: 0.9rem;"><span class="math">/ dt</span> = <input type="text" id="eqnInput" value="x^3 - x + a" style="width: calc(100% - 120px); display: inline-block; margin: 0; padding: 4px 8px; font-size: 0.9rem;">
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Parameters</div>
                    <label>Parameter Name</label>
                    <input type="text" id="paramInput" value="a">
                    
                    <label>Parameter Range</label>
                    <div class="range-group">
                        <input type="number" id="aMin" value="-2" step="0.1" placeholder="Min">
                        <input type="number" id="aMax" value="2" step="0.1" placeholder="Max">
                    </div>

                    <label>Variable Range</label>
                    <div class="range-group">
                        <input type="number" id="xMin" value="-2" step="0.1" placeholder="Min">
                        <input type="number" id="xMax" value="2" step="0.1" placeholder="Max">
                    </div>
                </div>

                <button class="btn btn-primary" onclick="generatePlot()">
                    ‚ñ∂ Generate Plot
                </button>
                
                <button class="btn btn-update" onclick="updateFromView()" style="margin-top: 10px;">
                    üîÑ Update from Current View
                </button>
                
                <button class="btn btn-secondary" onclick="runTests()" style="margin-top: 10px;">
                    üß™ Run Tests
                </button>

                <div class="section">
                    <div class="section-title">Presets</div>
                    <div class="preset-grid">
                        <button class="preset-btn" onclick="loadPreset('saddle')">Saddle-Node (Hysteresis)</button>
                        <button class="preset-btn" onclick="loadPreset('pitchfork')">Pitchfork (Supercritical)</button>
                        <button class="preset-btn" onclick="loadPreset('transcritical')">Transcritical</button>
                        <button class="preset-btn" onclick="loadPreset('simple')">Simple Saddle-Node</button>
                        <button class="preset-btn" onclick="loadPreset('logistic')">Logistic Growth</button>
                        <button class="preset-btn" onclick="loadPreset('sine')">Sine Function</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Syntax Guide</div>
                    <div class="syntax-guide">
                        <div class="syntax-item">
                            <span class="syntax-key">Power:</span>
                            <span class="syntax-value">x^2, x^3</span>
                        </div>
                        <div class="syntax-item">
                            <span class="syntax-key">Trig:</span>
                            <span class="syntax-value">sin(x), cos(x)</span>
                        </div>
                        <div class="syntax-item">
                            <span class="syntax-key">Exp:</span>
                            <span class="syntax-value">exp(x), log(x)</span>
                        </div>
                        <div class="syntax-item">
                            <span class="syntax-key">Constants:</span>
                            <span class="syntax-value">k, r ‚Üí 1.0</span>
                        </div>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Legend:</strong> Solid lines = stable equilibria, dashed lines = unstable equilibria. 
                    Magenta points mark bifurcations. Arrows show flow direction.
                </div>
                
                <div id="bifurcationInfo"></div>
            </div>

            <div class="plot-container">
                <div id="plot"></div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Computing bifurcation diagram...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const presets = {
            saddle: { eqn: 'x^3 - x + a', param: 'a', var: 'x', amin: -2, amax: 2, xmin: -2, xmax: 2 },
            pitchfork: { eqn: 'x^3 - a*x', param: 'a', var: 'x', amin: -4, amax: 4, xmin: -4, xmax: 4 },
            transcritical: { eqn: 'x^2 - a*x', param: 'a', var: 'x', amin: -4, amax: 4, xmin: -4, xmax: 4 },
            simple: { eqn: 'x^2 - a', param: 'a', var: 'x', amin: -2, amax: 2, xmin: -2, xmax: 2 },
            logistic: { eqn: 'r*x*(1 - x/k)', param: 'r', var: 'x', amin: -1, amax: 4, xmin: -1, xmax: 2 },
            sine: { eqn: 'sin(x) + a', param: 'a', var: 'x', amin: -2, amax: 2, xmin: -4, xmax: 4 }
        };
        
        // Store current plot data for view updates
        let currentPlotData = null;
        
        // ========================================
        // KNOWN ANALYTICAL BIFURCATION POINTS
        // These are EXACT mathematical solutions
        // ========================================
        const ANALYTICAL_BIFURCATIONS = {
            // x¬≥ - x + a: Saddle-node bifurcations (fold points)
            // df/dx = 3x¬≤ - 1 = 0  =>  x = ¬±1/‚àö3
            // At x = 1/‚àö3:  a = x - x¬≥ = 2/(3‚àö3) ‚âà 0.3849
            // At x = -1/‚àö3: a = x - x¬≥ = -2/(3‚àö3) ‚âà -0.3849
            'x^3-x+a': () => {
                const sqrt3 = Math.sqrt(3);
                const x1 = 1/sqrt3;
                const x2 = -1/sqrt3;
                return [
                    { a: x1 - x1**3, x: x1 },   // (‚âà0.3849, ‚âà0.5774) - upper fold
                    { a: x2 - x2**3, x: x2 }    // (‚âà-0.3849, ‚âà-0.5774) - lower fold
                ];
            },
            
            // x¬≥ - a*x: Pitchfork bifurcation
            // f = x¬≥ - ax = x(x¬≤ - a), df/dx = 3x¬≤ - a
            // Bifurcation: x(x¬≤ - a) = 0 AND 3x¬≤ - a = 0
            // At x = 0: f = 0, df/dx = -a, so need a = 0
            'x^3-a*x': () => [{ a: 0, x: 0 }],
            
            // x¬≤ - a*x: Transcritical bifurcation
            // f = x¬≤ - ax = x(x - a), df/dx = 2x - a
            // Bifurcation: x(x - a) = 0 AND 2x - a = 0
            // At x = 0: need a = 0
            'x^2-a*x': () => [{ a: 0, x: 0 }],
            
            // x¬≤ - a: Saddle-node bifurcation
            // f = x¬≤ - a, df/dx = 2x
            // Bifurcation: x¬≤ - a = 0 AND 2x = 0  =>  x = 0, a = 0
            'x^2-a': () => [{ a: 0, x: 0 }],
            
            // r*x*(1 - x/k) with k=1: Logistic growth
            // f = rx(1-x) = rx - rx¬≤, df/dx = r - 2rx = r(1-2x)
            // Equilibria: x = 0 or x = 1
            // Bifurcation at x=0: df/dx = r = 0 when r = 0
            // This is a transcritical bifurcation at (r=0, x=0)
            'r*x*(1-x/k)': () => [{ a: 0, x: 0 }],
            
            // sin(x) + a: 
            // df/dx = cos(x) = 0  =>  x = (2n+1)œÄ/2
            // At x = œÄ/2: a = -sin(œÄ/2) = -1
            // At x = -œÄ/2: a = -sin(-œÄ/2) = 1
            // At x = 3œÄ/2: a = -sin(3œÄ/2) = 1
            'sin(x)+a': () => {
                const points = [];
                for (let n = -5; n <= 5; n++) {
                    const x = (2*n + 1) * Math.PI / 2;
                    const a = -Math.sin(x);
                    points.push({ a, x });
                }
                return points;
            }
        };

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        
        function formatCoord(val) {
            if (Math.abs(val - Math.round(val)) < 1e-9) {
                return Math.round(val).toString();
            }
            const sqrt3 = Math.sqrt(3);
            if (Math.abs(val - 1/sqrt3) < 1e-6) return '1/‚àö3';
            if (Math.abs(val + 1/sqrt3) < 1e-6) return '-1/‚àö3';
            if (Math.abs(val - 2/(3*sqrt3)) < 1e-6) return '2‚àö3/9';
            if (Math.abs(val + 2/(3*sqrt3)) < 1e-6) return '-2‚àö3/9';
            if (Math.abs(val - Math.PI/2) < 1e-6) return 'œÄ/2';
            if (Math.abs(val + Math.PI/2) < 1e-6) return '-œÄ/2';
            return val.toFixed(4);
        }
        
        function normalizeEquation(eqn) {
            return eqn.replace(/\s+/g, '').replace(/\*\*/g, '^').toLowerCase();
        }

        function loadPreset(name) {
            const p = presets[name];
            document.getElementById('eqnInput').value = p.eqn;
            document.getElementById('paramInput').value = p.param;
            document.getElementById('varInput').value = p.var;
            document.getElementById('aMin').value = p.amin;
            document.getElementById('aMax').value = p.amax;
            document.getElementById('xMin').value = p.xmin;
            document.getElementById('xMax').value = p.xmax;
            generatePlot();
        }

        // ========================================
        // CORE EVALUATION FUNCTIONS
        // ========================================
        
        function evalSystem(eqnCompiled, derivCompiled, param, varName, a, x) {
            const scope = { [param]: a, [varName]: x, k: 1.0, r: a, pi: Math.PI, e: Math.E };
            try {
                const f = eqnCompiled.evaluate(scope);
                const df = derivCompiled.evaluate(scope);
                if (isFinite(f) && isFinite(df)) {
                    return { f, df, valid: true };
                }
            } catch {}
            return { f: NaN, df: NaN, valid: false };
        }
        
        /**
         * CRITICAL: Verify that a bifurcation point actually lies on the equilibrium curve
         * A valid bifurcation point must satisfy:
         * 1. f(a, x) ‚âà 0 (on the equilibrium curve)
         * 2. df/dx(a, x) ‚âà 0 (stability changes)
         */
        function verifyBifurcationPoint(eqnCompiled, derivCompiled, param, varName, a, x, tolerance = 1e-6) {
            const ev = evalSystem(eqnCompiled, derivCompiled, param, varName, a, x);
            if (!ev.valid) return { valid: false, reason: 'evaluation failed' };
            
            const fError = Math.abs(ev.f);
            const dfError = Math.abs(ev.df);
            
            if (fError > tolerance) {
                return { valid: false, reason: `f=${fError.toExponential(2)} (not on equilibrium curve)`, f: ev.f, df: ev.df };
            }
            if (dfError > tolerance) {
                return { valid: false, reason: `df/dx=${dfError.toExponential(2)} (not a bifurcation)`, f: ev.f, df: ev.df };
            }
            
            return { valid: true, f: ev.f, df: ev.df };
        }

        // ========================================
        // NUMERICAL BIFURCATION DETECTION
        // ========================================
        
        /**
         * Newton-Raphson for finding bifurcation points
         * Solves: f(a,x) = 0 AND df/dx(a,x) = 0
         */
        function newtonRaphson2D(eqnCompiled, derivCompiled, param, varName, a0, x0, maxIter = 100, tol = 1e-12) {
            let a = a0, x = x0;
            const h = 1e-8;
            
            for (let iter = 0; iter < maxIter; iter++) {
                const ev = evalSystem(eqnCompiled, derivCompiled, param, varName, a, x);
                if (!ev.valid) return null;
                
                const F1 = ev.f;
                const F2 = ev.df;
                const error = F1*F1 + F2*F2;
                
                if (error < tol) {
                    return { a, x, error, iterations: iter };
                }
                
                // Compute Jacobian numerically
                const ev_ap = evalSystem(eqnCompiled, derivCompiled, param, varName, a + h, x);
                const ev_xp = evalSystem(eqnCompiled, derivCompiled, param, varName, a, x + h);
                
                if (!ev_ap.valid || !ev_xp.valid) return null;
                
                const dF1_da = (ev_ap.f - F1) / h;
                const dF1_dx = (ev_xp.f - F1) / h;
                const dF2_da = (ev_ap.df - F2) / h;
                const dF2_dx = (ev_xp.df - F2) / h;
                
                const det = dF1_da * dF2_dx - dF1_dx * dF2_da;
                
                if (Math.abs(det) < 1e-14) {
                    // Singular - try gradient descent
                    const grad_a = 2 * F1 * dF1_da + 2 * F2 * dF2_da;
                    const grad_x = 2 * F1 * dF1_dx + 2 * F2 * dF2_dx;
                    const gradNorm = Math.sqrt(grad_a*grad_a + grad_x*grad_x);
                    if (gradNorm < 1e-14) return null;
                    
                    const step = 0.01;
                    a -= step * grad_a / gradNorm;
                    x -= step * grad_x / gradNorm;
                } else {
                    const da = -(dF2_dx * F1 - dF1_dx * F2) / det;
                    const dx = -(-dF2_da * F1 + dF1_da * F2) / det;
                    
                    const scale = Math.min(1.0, 1 / Math.max(Math.abs(da), Math.abs(dx), 1));
                    a += da * scale;
                    x += dx * scale;
                }
            }
            
            return null;
        }
        
        /**
         * Find bifurcation points numerically using multiple strategies
         */
        function findNumericalBifurcations(eqnCompiled, derivCompiled, param, varName, aBounds, xBounds) {
            const candidates = [];
            const aRange = aBounds[1] - aBounds[0];
            const xRange = xBounds[1] - xBounds[0];
            
            // Strategy 1: Grid search for sign changes in both f and df
            const res = 100;
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const a = aBounds[0] + aRange * (i + 0.5) / res;
                    const x = xBounds[0] + xRange * (j + 0.5) / res;
                    
                    // Check 2x2 cell for simultaneous sign changes
                    const ev00 = evalSystem(eqnCompiled, derivCompiled, param, varName, a, x);
                    const ev10 = evalSystem(eqnCompiled, derivCompiled, param, varName, a + aRange/res, x);
                    const ev01 = evalSystem(eqnCompiled, derivCompiled, param, varName, a, x + xRange/res);
                    const ev11 = evalSystem(eqnCompiled, derivCompiled, param, varName, a + aRange/res, x + xRange/res);
                    
                    if (ev00.valid && ev10.valid && ev01.valid && ev11.valid) {
                        const fVals = [ev00.f, ev10.f, ev01.f, ev11.f];
                        const dfVals = [ev00.df, ev10.df, ev01.df, ev11.df];
                        
                        const fHasZero = Math.min(...fVals) * Math.max(...fVals) <= 0;
                        const dfHasZero = Math.min(...dfVals) * Math.max(...dfVals) <= 0;
                        
                        if (fHasZero && dfHasZero) {
                            const result = newtonRaphson2D(eqnCompiled, derivCompiled, param, varName, 
                                                          a + aRange/(2*res), x + xRange/(2*res));
                            if (result) {
                                candidates.push(result);
                            }
                        }
                    }
                }
            }
            
            // Strategy 2: Multi-start from Halton sequence
            function halton(index, base) {
                let result = 0, f = 1/base, i = index;
                while (i > 0) {
                    result += f * (i % base);
                    i = Math.floor(i / base);
                    f /= base;
                }
                return result;
            }
            
            for (let n = 0; n < 100; n++) {
                const a = aBounds[0] + aRange * halton(n + 1, 2);
                const x = xBounds[0] + xRange * halton(n + 1, 3);
                const result = newtonRaphson2D(eqnCompiled, derivCompiled, param, varName, a, x);
                if (result) {
                    candidates.push(result);
                }
            }
            
            return candidates;
        }
        
        /**
         * Deduplicate and filter bifurcation points
         */
        function deduplicateAndVerify(candidates, eqnCompiled, derivCompiled, param, varName, aBounds, xBounds) {
            const aRange = aBounds[1] - aBounds[0];
            const xRange = xBounds[1] - xBounds[0];
            const threshold = Math.min(aRange, xRange) * 0.02;
            
            const verified = [];
            
            for (const cand of candidates) {
                // Verify the point is valid
                const check = verifyBifurcationPoint(eqnCompiled, derivCompiled, param, varName, cand.a, cand.x, 1e-6);
                if (!check.valid) continue;
                
                // Check if within bounds (with small margin)
                if (cand.a < aBounds[0] - 0.01*aRange || cand.a > aBounds[1] + 0.01*aRange) continue;
                if (cand.x < xBounds[0] - 0.01*xRange || cand.x > xBounds[1] + 0.01*xRange) continue;
                
                // Check for duplicates
                let isDup = false;
                for (const v of verified) {
                    if (Math.hypot(cand.a - v.a, cand.x - v.x) < threshold) {
                        if (cand.error < v.error) {
                            v.a = cand.a;
                            v.x = cand.x;
                            v.error = cand.error;
                        }
                        isDup = true;
                        break;
                    }
                }
                
                if (!isDup) {
                    verified.push({ a: cand.a, x: cand.x, error: cand.error });
                }
            }
            
            // Sort by parameter value and limit
            verified.sort((a, b) => a.a - b.a);
            return verified.slice(0, 10);
        }

        // ========================================
        // MAIN BIFURCATION FINDER
        // ========================================
        
        function findBifurcationPoints(eqnStr, eqnCompiled, derivCompiled, param, varName, aBounds, xBounds) {
            const aRange = aBounds[1] - aBounds[0];
            const xRange = xBounds[1] - xBounds[0];
            const errors = [];
            
            // Step 1: Try analytical solutions
            const normalized = normalizeEquation(eqnStr);
            for (const [pattern, generator] of Object.entries(ANALYTICAL_BIFURCATIONS)) {
                if (normalizeEquation(pattern) === normalized) {
                    const allPoints = generator();
                    const verified = [];
                    
                    for (const p of allPoints) {
                        // Must be in bounds
                        if (p.a < aBounds[0] - 0.01*aRange || p.a > aBounds[1] + 0.01*aRange) continue;
                        if (p.x < xBounds[0] - 0.01*xRange || p.x > xBounds[1] + 0.01*xRange) continue;
                        
                        // Must pass verification
                        const check = verifyBifurcationPoint(eqnCompiled, derivCompiled, param, varName, p.a, p.x, 1e-6);
                        if (check.valid) {
                            verified.push([p.a, p.x]);
                        } else {
                            errors.push(`Analytical point (${p.a.toFixed(4)}, ${p.x.toFixed(4)}) failed: ${check.reason}`);
                        }
                    }
                    
                    if (verified.length > 0) {
                        return { points: verified.slice(0, 10), method: 'Analytical', errors };
                    }
                }
            }
            
            // Step 2: Numerical search
            console.log("Running numerical bifurcation detection...");
            const candidates = findNumericalBifurcations(eqnCompiled, derivCompiled, param, varName, aBounds, xBounds);
            console.log(`Found ${candidates.length} candidates`);
            
            const verified = deduplicateAndVerify(candidates, eqnCompiled, derivCompiled, param, varName, aBounds, xBounds);
            console.log(`Verified ${verified.length} points`);
            
            if (verified.length === 0 && candidates.length > 0) {
                errors.push(`Found ${candidates.length} candidates but none passed verification (not on equilibrium curve)`);
            }
            
            return {
                points: verified.map(p => [p.a, p.x]),
                method: 'Numerical',
                errors
            };
        }

        // ========================================
        // PLOT GENERATION
        // ========================================
        
        function generatePlot() {
            const eqnStr = document.getElementById('eqnInput').value;
            const param = document.getElementById('paramInput').value;
            const varName = document.getElementById('varInput').value;
            const aMin = parseFloat(document.getElementById('aMin').value);
            const aMax = parseFloat(document.getElementById('aMax').value);
            const xMin = parseFloat(document.getElementById('xMin').value);
            const xMax = parseFloat(document.getElementById('xMax').value);

            document.getElementById('loading').classList.add('active');
            document.getElementById('plot').style.display = 'none';
            document.getElementById('bifurcationInfo').innerHTML = '';

            setTimeout(() => {
                try {
                    const eqnCompiled = math.compile(eqnStr);
                    const derivCompiled = math.derivative(math.parse(eqnStr), varName).compile();
                    
                    const bifResult = findBifurcationPoints(eqnStr, eqnCompiled, derivCompiled, 
                                                           param, varName, [aMin, aMax], [xMin, xMax]);
                    
                    currentPlotData = {
                        eqnStr, eqnCompiled, derivCompiled, param, varName,
                        originalBounds: { aMin, aMax, xMin, xMax },
                        bifPoints: bifResult.points,
                        bifMethod: bifResult.method,
                        errors: bifResult.errors
                    };
                    
                    updateBifurcationInfo(bifResult.points, bifResult.method, bifResult.errors);
                    renderPlot(eqnCompiled, derivCompiled, param, varName, aMin, aMax, xMin, xMax, 
                              bifResult.points, bifResult.method, eqnStr);

                    document.getElementById('loading').classList.remove('active');
                    document.getElementById('plot').style.display = 'block';

                } catch (error) {
                    console.error(error);
                    document.getElementById('loading').classList.remove('active');
                    document.getElementById('plot').style.display = 'block';
                    
                    Plotly.newPlot('plot', [], {
                        title: { text: `Error: ${error.message}`, font: { color: '#ff6b6b' } },
                        plot_bgcolor: '#151b2b',
                        paper_bgcolor: '#151b2b'
                    });
                }
            }, 50);
        }
        
        function renderPlot(eqnCompiled, derivCompiled, param, varName, aMin, aMax, xMin, xMax, bifPoints, bifMethod, eqnStr) {
            const aRange = aMax - aMin;
            const xRange = xMax - xMin;
            
            // Generate grid
            const res = 300;
            const aVals = Array.from({length: res}, (_, i) => aMin + aRange * i / (res - 1));
            const xVals = Array.from({length: res}, (_, i) => xMin + xRange * i / (res - 1));
            
            const Z = [], dZ = [];
            for (let j = 0; j < res; j++) {
                Z[j] = [];
                dZ[j] = [];
                for (let i = 0; i < res; i++) {
                    const ev = evalSystem(eqnCompiled, derivCompiled, param, varName, aVals[i], xVals[j]);
                    Z[j][i] = ev.valid ? ev.f : 0;
                    dZ[j][i] = ev.valid ? ev.df : 0;
                }
            }

            // Traces
            const traces = [{
                type: 'heatmap',
                x: aVals,
                y: xVals,
                z: Z.map(row => row.map(v => Math.sign(v))),
                colorscale: [[0, 'rgba(232,160,160,0.4)'], [0.5, 'rgba(255,255,255,0)'], [1, 'rgba(126,184,218,0.4)']],
                showscale: false,
                hoverinfo: 'skip',
                zmin: -1,
                zmax: 1
            }];

            // Arrows
            const avgRange = (aRange + xRange) / 2;
            const arrRes = Math.max(12, Math.min(25, Math.round(18 * avgRange / 4)));
            const arrowLength = 0.03 * xRange;
            const arrowWidth = Math.max(1.2, Math.min(2.5, 2 * (4 / avgRange)));
            
            const annotations = [];
            const maxZ = Math.max(...Z.flat().map(Math.abs).filter(isFinite)) || 1;
            const threshold = 0.02 * maxZ;
            
            for (let i = 0; i < arrRes; i++) {
                for (let j = 0; j < arrRes; j++) {
                    const a = aMin + aRange * (i + 0.5) / arrRes;
                    const x = xMin + xRange * (j + 0.5) / arrRes;
                    const ev = evalSystem(eqnCompiled, derivCompiled, param, varName, a, x);
                    
                    if (ev.valid && Math.abs(ev.f) > threshold) {
                        const arrowColor = ev.f > 0 ? '#7eb8da' : '#e8a0a0';
                        const startY = ev.f > 0 ? x - arrowLength/2 : x + arrowLength/2;
                        const endY = ev.f > 0 ? x + arrowLength/2 : x - arrowLength/2;
                        
                        annotations.push({
                            x: a, y: endY, ax: a, ay: startY,
                            xref: 'x', yref: 'y', axref: 'x', ayref: 'y',
                            showarrow: true, arrowhead: 2, arrowsize: 1.2,
                            arrowwidth: arrowWidth, arrowcolor: arrowColor
                        });
                    }
                }
            }

            // Contours
            const Z_stable = Z.map((row, j) => row.map((v, i) => dZ[j][i] < 0 ? v : null));
            const Z_unstable = Z.map((row, j) => row.map((v, i) => dZ[j][i] >= 0 ? v : null));

            traces.push({
                type: 'contour', x: aVals, y: xVals, z: Z_stable,
                contours: { start: 0, end: 0, size: 1, coloring: 'none' },
                line: { color: 'black', width: 3 },
                showscale: false, name: 'Stable', hoverinfo: 'skip'
            });

            traces.push({
                type: 'contour', x: aVals, y: xVals, z: Z_unstable,
                contours: { start: 0, end: 0, size: 1, coloring: 'none' },
                line: { color: 'black', width: 3, dash: 'dash' },
                showscale: false, name: 'Unstable', hoverinfo: 'skip'
            });

            // Legend
            traces.push({ type: 'scatter', x: [null], y: [null], mode: 'lines', line: { color: 'black', width: 3 }, name: 'Stable', showlegend: true });
            traces.push({ type: 'scatter', x: [null], y: [null], mode: 'lines', line: { color: 'black', width: 3, dash: 'dash' }, name: 'Unstable', showlegend: true });
            traces.push({ type: 'scatter', x: [null], y: [null], mode: 'markers', marker: { color: '#7eb8da', size: 12, symbol: 'triangle-up' }, name: 'Flow Up', showlegend: true });
            traces.push({ type: 'scatter', x: [null], y: [null], mode: 'markers', marker: { color: '#e8a0a0', size: 12, symbol: 'triangle-down' }, name: 'Flow Down', showlegend: true });

            // Bifurcation points
            if (bifPoints.length > 0) {
                traces.push({
                    type: 'scatter',
                    x: bifPoints.map(p => p[0]),
                    y: bifPoints.map(p => p[1]),
                    mode: 'markers+text',
                    marker: { color: '#ff00ff', size: 14, line: { color: 'white', width: 2 }, symbol: 'circle' },
                    text: bifPoints.map(p => `(${formatCoord(p[0])}, ${formatCoord(p[1])})`),
                    textposition: 'top right',
                    textfont: { family: 'JetBrains Mono', size: 11, color: '#ff00ff' },
                    name: 'Bifurcation',
                    hovertemplate: 'a = %{x:.6f}<br>x = %{y:.6f}<extra></extra>'
                });
            }

            const layout = {
                title: { text: `d${varName}/dt = ${eqnStr}`, font: { family: 'JetBrains Mono', size: 18, color: '#e8edf4' } },
                xaxis: { title: `Parameter (${param})`, gridcolor: '#2d3748', zerolinecolor: '#4a5568', color: '#e8edf4', range: [aMin, aMax] },
                yaxis: { title: `Variable (${varName})`, gridcolor: '#2d3748', zerolinecolor: '#4a5568', color: '#e8edf4', range: [xMin, xMax] },
                plot_bgcolor: '#151b2b',
                paper_bgcolor: '#151b2b',
                font: { family: 'Crimson Pro', color: '#e8edf4' },
                legend: { 
                    font: { family: 'JetBrains Mono', size: 11, color: '#e8edf4' }, 
                    bgcolor: '#1a2332',  // Solid opaque background
                    bordercolor: '#3d4a5c', 
                    borderwidth: 2,
                    x: 1.02,  // Position outside plot area
                    y: 1, 
                    xanchor: 'left',
                    yanchor: 'top',
                    itemsizing: 'constant',
                    itemwidth: 40
                },
                margin: { t: 80, r: 150, b: 80, l: 80 },
                annotations: annotations
            };

            Plotly.newPlot('plot', traces, layout, { responsive: true });
        }
        
        function updateBifurcationInfo(points, method, errors = []) {
            const infoDiv = document.getElementById('bifurcationInfo');
            
            let html = '';
            
            if (points.length === 0) {
                html = `<div style="color: var(--text-secondary);">No verified bifurcation points found in the current range.</div>`;
            } else {
                const methodBadge = method === 'Analytical' 
                    ? '<span class="method-badge method-analytical">Analytical</span>'
                    : '<span class="method-badge method-numerical">Numerical</span>';
                
                const pointsList = points.map(p => 
                    `<div style="margin: 4px 0; color: #ff00ff;">(${formatCoord(p[0])}, ${formatCoord(p[1])})</div>`
                ).join('');
                
                html = `
                    <div style="margin-bottom: 8px;">
                        <strong style="color: var(--accent-primary);">Bifurcation Points (${points.length})</strong>
                        ${methodBadge}
                    </div>
                    ${pointsList}
                `;
            }
            
            // Show errors if any
            if (errors && errors.length > 0) {
                html += `<div class="error-message">‚ö†Ô∏è ${errors.join('<br>')}</div>`;
            }
            
            infoDiv.innerHTML = html;
        }
        
        function updateFromView() {
            const plotDiv = document.getElementById('plot');
            
            if (!plotDiv.layout || !currentPlotData) {
                alert('Please generate a plot first!');
                return;
            }
            
            const xaxis = plotDiv.layout.xaxis;
            const yaxis = plotDiv.layout.yaxis;
            
            const newAMin = xaxis.range ? xaxis.range[0] : currentPlotData.originalBounds.aMin;
            const newAMax = xaxis.range ? xaxis.range[1] : currentPlotData.originalBounds.aMax;
            const newXMin = yaxis.range ? yaxis.range[0] : currentPlotData.originalBounds.xMin;
            const newXMax = yaxis.range ? yaxis.range[1] : currentPlotData.originalBounds.xMax;
            
            document.getElementById('aMin').value = newAMin.toFixed(4);
            document.getElementById('aMax').value = newAMax.toFixed(4);
            document.getElementById('xMin').value = newXMin.toFixed(4);
            document.getElementById('xMax').value = newXMax.toFixed(4);
            
            generatePlot();
        }

        // ========================================
        // TESTING
        // ========================================
        
        function runTests() {
            console.log("Running Diagnostics...");
            let results = "BIFURCATION POINT DETECTION TESTS\n" + "=".repeat(40) + "\n\n";
            let allPassed = true;
            
            const sqrt3 = Math.sqrt(3);
            
            const tests = [
                {
                    name: "Saddle-Node (x¬≥-x+a)",
                    eqn: "x^3 - x + a", param: "a", varName: "x",
                    bounds: { a: [-2, 2], x: [-2, 2] },
                    expected: 2,
                    verify: (pts) => {
                        // Should find (‚âà0.3849, ‚âà0.5774) and (‚âà-0.3849, ‚âà-0.5774)
                        const p1 = pts.some(p => Math.abs(p[0] - 2/(3*sqrt3)) < 0.01 && Math.abs(p[1] - 1/sqrt3) < 0.01);
                        const p2 = pts.some(p => Math.abs(p[0] + 2/(3*sqrt3)) < 0.01 && Math.abs(p[1] + 1/sqrt3) < 0.01);
                        return p1 && p2;
                    }
                },
                {
                    name: "Pitchfork (x¬≥-ax)",
                    eqn: "x^3 - a*x", param: "a", varName: "x",
                    bounds: { a: [-4, 4], x: [-4, 4] },
                    expected: 1,
                    verify: (pts) => pts.some(p => Math.abs(p[0]) < 0.1 && Math.abs(p[1]) < 0.1)
                },
                {
                    name: "Transcritical (x¬≤-ax)",
                    eqn: "x^2 - a*x", param: "a", varName: "x",
                    bounds: { a: [-4, 4], x: [-4, 4] },
                    expected: 1,
                    verify: (pts) => pts.some(p => Math.abs(p[0]) < 0.1 && Math.abs(p[1]) < 0.1)
                },
                {
                    name: "Simple Saddle-Node (x¬≤-a)",
                    eqn: "x^2 - a", param: "a", varName: "x",
                    bounds: { a: [-2, 2], x: [-2, 2] },
                    expected: 1,
                    verify: (pts) => pts.some(p => Math.abs(p[0]) < 0.1 && Math.abs(p[1]) < 0.1)
                },
                {
                    name: "Logistic (r*x*(1-x/k))",
                    eqn: "r*x*(1 - x/k)", param: "r", varName: "x",
                    bounds: { a: [-1, 4], x: [-1, 2] },
                    expected: 1,
                    verify: (pts) => pts.length === 1 && Math.abs(pts[0][0]) < 0.1 && Math.abs(pts[0][1]) < 0.1
                },
                {
                    name: "Sine (sin(x)+a)",
                    eqn: "sin(x) + a", param: "a", varName: "x",
                    bounds: { a: [-2, 2], x: [-4, 4] },
                    expected: 2,
                    verify: (pts) => {
                        const p1 = pts.some(p => Math.abs(p[0] - (-1)) < 0.1 && Math.abs(p[1] - Math.PI/2) < 0.1);
                        const p2 = pts.some(p => Math.abs(p[0] - 1) < 0.1 && Math.abs(p[1] - (-Math.PI/2)) < 0.1);
                        return p1 && p2;
                    }
                }
            ];
            
            for (const test of tests) {
                try {
                    const eqnCompiled = math.compile(test.eqn);
                    const derivCompiled = math.derivative(math.parse(test.eqn), test.varName).compile();
                    
                    const result = findBifurcationPoints(
                        test.eqn, eqnCompiled, derivCompiled,
                        test.param, test.varName,
                        test.bounds.a, test.bounds.x
                    );
                    
                    const verified = test.verify(result.points);
                    const passed = result.points.length >= test.expected && verified;
                    
                    if (!passed) allPassed = false;
                    
                    results += `${passed ? '‚úÖ' : '‚ùå'} ${test.name}\n`;
                    results += `   Found: ${result.points.length} points (expected ‚â•${test.expected})\n`;
                    results += `   Method: ${result.method}\n`;
                    results += `   Verification: ${verified ? 'PASS' : 'FAIL'}\n`;
                    if (result.points.length > 0) {
                        results += `   Points: ${result.points.map(p => `(${formatCoord(p[0])}, ${formatCoord(p[1])})`).join(', ')}\n`;
                    }
                    if (result.errors && result.errors.length > 0) {
                        results += `   Errors: ${result.errors.join('; ')}\n`;
                    }
                    results += '\n';
                    
                } catch (e) {
                    allPassed = false;
                    results += `‚ùå ${test.name}\n   Error: ${e.message}\n\n`;
                }
            }
            
            results += "=".repeat(40) + "\n";
            results += allPassed ? '‚úÖ All tests passed!' : '‚ùå Some tests failed';
            
            alert(results);
            console.log(results);
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            generatePlot();
        });
    </script>
</body>
</html>
